<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Robot Collector Game</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial;
      background-color: #cccccc;
    }
    canvas {
      display: block;
      background: #cccccc;
    }
    #hud, #pauseText, #startScreen, #pauseBtn {
      position: absolute;
      color: #111;
      font-size: 1.5em;
      font-family: Arial;
      z-index: 10;
    }
    #hud {
      top: 10px;
      left: 10px;
    }
    #pauseText {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: none;
      font-size: 2em;
    }
    #startScreen {
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 2em;
      box-sizing: border-box;
    }
    #pauseBtn {
      top: 10px;
      right: 10px;
      background: #eee;
      padding: 0.5em 1em;
      border-radius: 10px;
      border: 1px solid #aaa;
      cursor: pointer;
      user-select: none;
    }
  </style>
</head>
<body>
  <div id="hud">
    Score: <span id="score">0</span><br />
    Budget: <span id="budget">100</span>
  </div>
  <div id="pauseText">Paused</div>
  <div id="startScreen">
    <div>
      <h1>Robot Collector Game</h1>
      <p>Collect the 200-value items to score points and increase speed.</p>
      <p>Avoid too many hits or youâ€™ll run out of budget.</p>
      <p>Items worth 500 slow you down.</p>
      <p>Jump: <strong>Space / Tap Left</strong> &nbsp;&nbsp; Duck: <strong>Arrow Down / Touch Right</strong> &nbsp;&nbsp; Pause: <strong>P / Button</strong></p>
      <p>Press any key or tap to start!</p>
    </div>
  </div>
  <div id="pauseBtn">Pause</div>
  <canvas id="gameCanvas"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    ctx.canvas.width = window.innerWidth;
    ctx.canvas.height = window.innerHeight / 2;

    const cloudImage = new Image();
    cloudImage.src = "cloud.png";

    const robotImage = new Image();
    robotImage.src = "robot.png";

    const groundHeight = 120;
    let paused = false;
    let started = false;

    const robot = {
      x: 100,
      y: 0,
      width: 90,
      height: 120,
      vy: 0,
      jumpPower: -10,
      gravity: 0.5,
      onGround: true,
      ducking: false,
      normalHeight: 120,
      duckHeight: 60,
    };

    let items = [];
    let clouds = [];
    let speed = 3;
    let score = 0;
    let budget = 100;
    let gameOver = false;
    let frameCount = 0;

    const itemValues = [100, 200, 300, 400, 500];

    function getGroundLevel(h) {
      return canvas.height - groundHeight - h;
    }

    robot.y = getGroundLevel(robot.height);

    const numClouds = Math.floor(window.innerWidth / 200);
    for (let i = 0; i < numClouds; i++) {
      clouds.push({
        x: Math.random() * canvas.width,
        y: Math.random() * 100,
        width: 120 + Math.random() * 60,
        height: 120,
        speed: 0.2 + Math.random() * 0.2
      });
    }

    function spawnItem() {
      const value = itemValues[Math.floor(Math.random() * itemValues.length)];
      const is500 = speed > 5 && Math.random() < 0.3;
      const finalValue = is500 ? 500 : value;
      const baseY = getGroundLevel(140);
      const offset = Math.random() * 60;
      const randomY = baseY - offset;
      items.push({
        x: canvas.width + 5,
        y: randomY,
        width: 30,
        height: 30,
        value: finalValue
      });
    }

    function update() {
      if (!started || gameOver || paused) return;

      robot.vy += robot.gravity;
      robot.y += robot.vy;

      const targetHeight = robot.ducking ? robot.duckHeight : robot.normalHeight;
      const groundLevel = getGroundLevel(targetHeight);

      if (robot.y >= groundLevel) {
        robot.y = groundLevel;
        robot.vy = 0;
        robot.onGround = true;
      } else {
        robot.onGround = false;
      }

      robot.height = targetHeight;

      for (let i = items.length - 1; i >= 0; i--) {
        const item = items[i];
        item.x -= speed;

        if (
          robot.x < item.x + item.width &&
          robot.x + robot.width > item.x &&
          robot.y < item.y + item.height &&
          robot.y + robot.height > item.y
        ) {
          budget -= 1;

          if (item.value === 200) {
            score += 1;
            speed += 0.5;
          } else if (item.value === 500) {
            speed = Math.max(0, speed - 0.5);
          }

          items.splice(i, 1);
        } else if (item.x + item.width < 0) {
          items.splice(i, 1);
        }
      }

      for (let cloud of clouds) {
        cloud.x -= cloud.speed;
        if (cloud.x + cloud.width < 0) {
          cloud.x = canvas.width + Math.random() * 100;
          cloud.y = Math.random() * 100;
        }
      }

      if (budget <= 0 || speed <= 0) {
        gameOver = true;
        alert("Game Over!");
      }

      document.getElementById("score").innerText = score;
      document.getElementById("budget").innerText = budget;

      frameCount++;
      if (frameCount % 60 === 0) spawnItem();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      skyGradient.addColorStop(0, '#cccccc');
      skyGradient.addColorStop(1, '#eeeeee');
      ctx.fillStyle = skyGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      for (let cloud of clouds) {
        ctx.drawImage(cloudImage, cloud.x, cloud.y, cloud.width, cloud.height);
      }

      const groundY = canvas.height - groundHeight;
      const groundGradient = ctx.createLinearGradient(0, groundY, 0, canvas.height);
      groundGradient.addColorStop(0, '#eeeeee');
      groundGradient.addColorStop(1, '#cccccc');
      ctx.fillStyle = groundGradient;
      ctx.fillRect(0, groundY, canvas.width, groundHeight);

      ctx.drawImage(robotImage, robot.x, robot.y, robot.width, robot.height);

      for (let item of items) {
        ctx.fillStyle = "#111";
        ctx.font = "20px Arial";
        ctx.fillText(item.value, item.x, item.y + item.height);
      }
    }

    function loop() {
      update();
      draw();
      if (!gameOver) requestAnimationFrame(loop);
    }

    document.addEventListener("keydown", (e) => {
      if (!started) {
        started = true;
        document.getElementById("startScreen").style.display = "none";
        loop();
        return;
      }
      if (e.code === "Space" && robot.onGround && !robot.ducking) {
        robot.vy = robot.jumpPower;
      }
      if (e.code === "ArrowDown") {
        robot.ducking = true;
      }
      if (e.code === "KeyP") {
        paused = !paused;
        document.getElementById("pauseText").style.display = paused ? "block" : "none";
      }
    });

    document.addEventListener("keyup", (e) => {
      if (e.code === "ArrowDown") {
        robot.ducking = false;
      }
    });

    document.getElementById("pauseBtn").addEventListener("click", () => {
      paused = !paused;
      document.getElementById("pauseText").style.display = paused ? "block" : "none";
    });

    document.addEventListener("touchstart", (e) => {
      if (!started) {
        started = true;
        document.getElementById("startScreen").style.display = "none";
        loop();
        return;
      }
      const touchX = e.touches[0].clientX;
      const halfWidth = window.innerWidth / 2;
      if (touchX < halfWidth && robot.onGround && !robot.ducking) {
        robot.vy = robot.jumpPower;
      } else {
        robot.ducking = true;
      }
    });

    document.addEventListener("touchend", (e) => {
      robot.ducking = false;
    });

    robotImage.onload = () => {
      // Waits for key press or tap to start
    };
  </script>
</body>
</html>
